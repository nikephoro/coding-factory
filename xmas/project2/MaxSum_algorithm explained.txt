Έστω ένας πίνακας θετικών και αρνητικών ακεραίων arr και έστω υποπίνακας maxSum του arr τέτοιος ώστε το άθροισμα των στοιχείων του maxSum να είναι το μέγιστο δυνατό άθροισμα
ακεραίων του arr.

Ακόμη έστω localSum το τοπικό άθροισμα μιας περιοχής του arr και globalMax το ολικό μέγιστο (το ζητούμενο άθροισμα, δηλαδή το άθροισμα των στοιχείων του maxSum).


Για να σχεδιάσουμε έναν αλγόριθμο πολυπλοκότητας Ο(n) , χρειάζεται να διατρέξουμε μία και μόνο φορά τον arr και να υπολογίσουμε το globalMax. Έτσι διασφαλίζουμε
ότι για n στοιχεία πίνακα έχουμε n επαναλήψεις (γραμμική πολυπλοκότητα).



'Εστω ο πίνακας arr = { 0, 2, -4, 9, 12, 1} και i o δείκτης της θέσης των στοιχείων του.


Θα κρατήσουμε με αφετηρία το 0 ,το άθροισμα των στοιχείων που συναντάμε, στο localSum.


Άρα localSum = arr[0] για i = 0.

    localSum = arr[0] + arr[1] για i = 1 ... και ούτω καθεξής.


Ακόμη θα αρχικοποιήσουμε το ολικό μέγιστο ως globalMax = arr[0] και σε κάθε επανάληψη, θα
συγκρίνουμε το localSum με το globalMax, έτσι ώστε αν localSum > globalMax , να γίνεται η εκχώρηση {globalMax = localSum;}

1) Εφόσον σε κάθε επανάληψη συγκρίνουμε το localSum με το globalMax, το globalMax δεν θα μειωθεί αν αρχίσουμε να συναντάμε αρνητικούς.


Μέχρι εδώ το πρόβλημα μοιάζει σχεδόν λυμένο. Ωστόσο επειδή ο arr έχει και αρνητικούς:

2) θα μπορούσε ένας υποπίνακάς του, που ΔΕΝ ξεκινάει από το arr[0], αλλά
από κάποιο ενδιάμεσο στοιχείο, να έχει μεγαλύτερο άθροισμα από κάθε υποπίνακα που ξεκινάει από το arr[0].


Για να δώσουμε λύση αρκεί αρκεί να παρατηρήσουμε ότι το localSum, για i =2 είναι -2 ενώ για i = 3 είναι 7. Άρα
 

3) Αν το localSum γίνει αρνητικό, ο επόμενος θετικός είναι μεγαλύτερος από το άθροισμα των στοιχείων του τρέχοντος υποπίνακα.

Άρα αν localSum < 0, θα πρέπει να διακόψουμε την άθροιση στοιχείων από την αρχή του πίνακα και να ξεκινήσουμε ξανά με αφετηρία τον αμέσως
επόμενο θετικό.



Ο πιο απλός τρόπος να υλοποιηθεί το (3) είναι να ελέγχουμε σε κάθε επανάληψη αν το localSum έγινε αρνητικό, και αν ναι, να εκχωρήσουμε στο localSum το arr[i] αντί να 
το προσαυξήσουμε κατά arr[i]. 

Έτσι, σταματάμε να "κουβαλάμε" το αρνητικό υπόλοιπο και συνεχίζουμε την πρόσθεση ακεραίων με τη μέγιστη δυνατή τιμή (τοπικά), δηλαδή τον πρώτο θετικό ακέραιο που συναντάμε.

Αν συναντάμε μόνο αρνητικούς, το localSum και πάλι θα αλλάζει, ωστόσο δε μας πειράζει αφού στο globalMax θα παραμένει ο μικρότερος.



Από 1,2,3 και με επαγωγή, προκύπτει ότι θα σαρωθεί όλος ο πίνακας, ξεκινώντας από τα αριστερά, κρατώντας στο localMax τα επιμέρους αθροίσματα υποπινάκων όσο είναι θετικά,
και στο globalMax το μεγαλύτερο ανάμεσά τους (δυνητικά το μόνο θετικό στοιχείο ή το μικρότερο αρνητικό).















